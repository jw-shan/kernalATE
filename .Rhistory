num <- vector()
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
num = c(num,i)
}
}
X <- X[-num,]
Y <- Y[-num]
Z <- Z[-num]
D <- D[-num]
N <- length(D)
KSE1_est <- KSE_1(X,Y,D,Z,h)
n = length(Z)
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(K_x[,i] * (Z==Z[i]))
de <- sum(K_x[,i])
res[i] = nu/de
}
K_x = K(X,h)
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(K_x[,i] * (Z==Z[i]))
de <- sum(K_x[,i])
res[i] = nu/de
}
which(is.nan(res))
ind=1
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(D * K_x[,i] * (Z==ind))
de <- sum(K_x[,i] * (Z==ind))
res[i] = nu/de
}
which(is.nan(res))
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(Y * K_x[,i] * (Z==ind))
de <- sum(K_x[,i] * (Z==ind))
res[i] = nu/de
}
which(is.nan(res))
ind=0
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(Y * K_x[,i] * (Z==ind))
de <- sum(K_x[,i] * (Z==ind))
res[i] = nu/de
}
ind=0
which(is.nan(res))
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(K_x[,i] * (Z==Z[i]))
de <- sum(K_x[,i])
res[i] = nu/de
}
which(is.nan(res))
res = vector(length = n)
for (i in seq(n)) {
nu <- sum(D * K_x[,i] * (Z==ind))
de <- sum(K_x[,i] * (Z==ind))
res[i] = nu/de
}
which(is.nan(res))
pDhat(1,X,Z,D,h,K_x)-pDhat(0,X,Z,D,h,K_x)
res=pDhat(1,X,Z,D,h,K_x)-pDhat(0,X,Z,D,h,K_x)
which(res==0)
a <- c(1,2,3,4,5,6)
a[-c(2,3,1,2)]
a <- c(1,2,3,4,5,6)
a[-c(2,4,1,2)]
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
btstrap.each = 500
h <- 1.06* N^{-1/8}
X = X.mat[,c(2:4, 8,9,12, 14, 19,20,22)]
X = data.frame(X)
X$age        = scale(X$age)
X$fatheduc   = scale(X$fatheduc)
X$motheduc   = scale(X$motheduc)
X$iq         = scale(X$iq)
### romove f(z|x)=0 and delta^D=0
K_x0 = K(X,h)
num <- vector()
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
num = c(num,i)
}
}
ind0 = which(deltaDhat(X,Z,D,h,K_x0)==0)
ind0
num = c(num,ind0)
X <- X[-num,]
Y <- Y[-num]
Z <- Z[-num]
D <- D[-num]
N <- length(D)
KSE1_est <- KSE_1(X,Y,D,Z,h)
KSE1_est
K_x = K(X,h)
sum( (2*Z-1)/fhat(X,Z,h,K_x)*
Y/deltaDhat(X,Z,D,h,K_x) ) /N
fhat(X,Z,h,K_x)
min(fhat(X,Z,h,K_x))
1/min(fhat(X,Z,h,K_x))
min(deltaDhat(X,Z,D,h,K_x))
min(abs(deltaDhat(X,Z,D,h,K_x)))
quantile(abs(deltaDhat(X,Z,D,h,K_x)),seq(0,1,0.05))
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
btstrap.each = 500
h <- 1.06* N^{-1/8}
X = X.mat[,c(2:4, 8,9,12, 14, 19,20,22)]
X = data.frame(X)
X$age        = scale(X$age)
X$fatheduc   = scale(X$fatheduc)
X$motheduc   = scale(X$motheduc)
X$iq         = scale(X$iq)
### romove f(z|x)=0 and delta^D=0
K_x0 = K(X,h)
num <- vector()
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
num = c(num,i)
}
}
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<e-4)
num = c(num,ind0)
X <- X[-num,]
Y <- Y[-num]
Z <- Z[-num]
D <- D[-num]
N <- length(D)
K_x = K(X,h)
sum( (2*Z-1)/fhat(X,Z,h,K_x)*
Y/deltaDhat(X,Z,D,h,K_x) ) /N
10^(-4)
1e-04
1e-4
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
btstrap.each = 500
h <- 1.06* N^{-1/8}
X = X.mat[,c(2:4, 8,9,12, 14, 19,20,22)]
X = data.frame(X)
X$age        = scale(X$age)
X$fatheduc   = scale(X$fatheduc)
X$motheduc   = scale(X$motheduc)
X$iq         = scale(X$iq)
### romove f(z|x)=0 and delta^D=0
K_x0 = K(X,h)
num <- vector()
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
num = c(num,i)
}
}
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-4)
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-5)
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-6)
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-10)
quantile(deltaDhat(X,Z,D,h,K_x0),seq(0,1,0.05))
which(is.na(deltaDhat(X,Z,D,h,K_x0)))
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
btstrap.each = 500
h <- 1.06* N^{-1/8}
X = X.mat[,c(2:4, 8,9,12, 14, 19,20,22)]
X = data.frame(X)
X$age        = scale(X$age)
X$fatheduc   = scale(X$fatheduc)
X$motheduc   = scale(X$motheduc)
X$iq         = scale(X$iq)
### romove f(z|x)=0 and delta^D=0
K_x0 = K(X,h)
num <- vector()
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
btstrap.each = 500
h <- 1.06* N^{-1/8}
X = X.mat[,c(2:4, 8,9,12, 14, 19,20,22)]
X = data.frame(X)
X$age        = scale(X$age)
X$fatheduc   = scale(X$fatheduc)
X$motheduc   = scale(X$motheduc)
X$iq         = scale(X$iq)
### romove f(z|x)=0 and delta^D=0
K_x0 = K(X,h)
num <- vector()
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
num = c(num,i)
}
}
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-10)
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
num = c(num,i)
}
}
X <- X[-num,]
Y <- Y[-num]
Z <- Z[-num]
D <- D[-num]
N <- length(D)
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
btstrap.each = 500
h <- 1.06* N^{-1/8}
X = X.mat[,c(2:4, 8,9,12, 14, 19,20,22)]
X = data.frame(X)
X$age        = scale(X$age)
X$fatheduc   = scale(X$fatheduc)
X$motheduc   = scale(X$motheduc)
X$iq         = scale(X$iq)
### romove f(z|x)=0
K_x0 = K(X,h)
ind0 <- vector()
for (i in 1:N) {
f_1 <- K_x0[,i] * (Z==1)
f_0 <- K_x0[,i] * (Z==0)
if (sum(f_1)==0 | sum(f_0)==0) {
ind0 = c(ind0,i)
}
}
X <- X[-ind0,]
Y <- Y[-ind0]
Z <- Z[-ind0]
D <- D[-ind0]
N <- length(D)
### remove delta^D=0
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-10)
warnings()
### remove delta^D=0
K_x0 = K(X,h)
ind0 = which(deltaDhat(X,Z,D,h,K_x0)<1e-10)
### remove delta^D=0
h <- 1.06* N^{-1/8}
K_x0 = K(X,h)
quantile(deltaDhat(X,Z,D,h,K_x0),seq(0,1,0.05))
ind0 = which(abs(deltaDhat(X,Z,D,h,K_x0))<1e-10)
ind0 = which(abs(deltaDhat(X,Z,D,h,K_x0))<1e-5)
ind0 = which(abs(deltaDhat(X,Z,D,h,K_x0))<1e-6 )
ind0 = which(abs(deltaDhat(X,Z,D,h,K_x0))<1e-6)
X <- X[-ind0,]
Y <- Y[-ind0]
Z <- Z[-ind0]
D <- D[-ind0]
N <- length(D)
KSE1_est <- KSE_1(X,Y,D,Z,h)
### remove delta^D=0
h <- 1.06* N^{-1/8}
K_x = K(X,h)
sum( (2*Z-1)/fhat(X,Z,h,K_x)*
Y/deltaDhat(X,Z,D,h,K_x) ) /N
which(fhat(X,Z,h,K_x)==0)
fhat(X,Z,h,K_x)
deltaDhat(X,Z,D,h,K_x)
summary(deltaDhat(X,Z,D,h,K_x))
which(is.na(deltaDhat(X,Z,D,h,K_x)))
res = pDhat(0,X,Z,D,h,K_x)
res[1773]
rm(list=ls())
load("3.1 NLS.RData")
source("3.2 KernelEstimators.R")
### Data cleaning
X = as.data.frame(X.mat[,c(2:4, 8,9,12, 14)])
colnames(X)
mean(X$smsa66)
mean(X$black)
mean(X$south66)
View(X)
install.packages(c("crs", "ncvreg", "np"))
library(np)
?npregbw
band = npregbw(Z~X)
### Data cleaning
X = X.mat[,c(2:4, 8,9,12, 14)]
band = npregbw(Z~X)
rm(list=ls())
library(parallel)
load("E:/OneDrive/RUC/Research/Treatment/kernel estimation of ATE/paper/CodeATE/result.RData")
result <- matrix(nrow = 4, ncol = 5)
colnames(result)<-c("bias","stdev","MSE","RMSE","CR")
rownames(result)<-c("T1","T2","T3","T")
for (i in 1:4) {
Delta <- mean(est[,i])
bias  <- Delta - truevalue
mse   <- 1/J*(sum((est[,i]-truevalue)^2))
stdev <- sqrt(1/J*(sum((est[,i]-Delta)^2)))
rmse<- sqrt(mse)
count<-0
for(j in 1:J){
if(est[j,i]> 0.087-1.96*stdev & est[j,i]< 0.087+1.96*stdev)
count<- count+1
}
coverage_rate <<- count/J
CR <- coverage_rate
result[i,] <- cbind(bias,stdev,mse,rmse,CR)
}
result
load("E:/OneDrive/RUC/Research/Treatment/kernel estimation of ATE/paper/CodeATE/result500.RData")
result <- matrix(nrow = 4, ncol = 5)
colnames(result)<-c("bias","stdev","MSE","RMSE","CR")
rownames(result)<-c("T1","T2","T3","T")
for (i in 1:4) {
Delta <- mean(est[,i])
bias  <- Delta - truevalue
mse   <- 1/J*(sum((est[,i]-truevalue)^2))
stdev <- sqrt(1/J*(sum((est[,i]-Delta)^2)))
rmse<- sqrt(mse)
count<-0
for(j in 1:J){
if(est[j,i]> 0.087-1.96*stdev & est[j,i]< 0.087+1.96*stdev)
count<- count+1
}
coverage_rate <<- count/J
CR <- coverage_rate
result[i,] <- cbind(bias,stdev,mse,rmse,CR)
}
result
result <- matrix(nrow = 4, ncol = 4)
colnames(result)<-c("bias","stdev","RMSE","CR")
rownames(result)<-c("T1","T2","T3","T")
for (i in 1:4) {
Delta <- mean(est[,i])
bias  <- Delta - truevalue
mse   <- 1/J*(sum((est[,i]-truevalue)^2))
stdev <- sqrt(1/J*(sum((est[,i]-Delta)^2)))
rmse<- sqrt(mse)
count<-0
for(j in 1:J){
if(est[j,i]> 0.087-1.96*stdev & est[j,i]< 0.087+1.96*stdev)
count<- count+1
}
coverage_rate <<- count/J
CR <- coverage_rate
result[i,] <- cbind(bias,stdev,rmse,CR)
}
result
rm(list=ls())
library(parallel)
source("1.1 Datagen_1D.R")
source("1.2.1 KernelEstimators.R")
source("1.3 plot.R")
## Monto Carlo times and Sample Size###
seed = 300
library(parallel)
source("1.1 Datagen_1D.R")
source("1.2.1 KernelEstimators.R")
source("1.3 plot.R")
install.packages("cowplot")
source("1.1 Datagen_1D.R")
source("1.2.1 KernelEstimators.R")
source("1.3 plot.R")
## Monto Carlo times and Sample Size###
seed = 300
J <- 500
N <- 500
truevalue<- 0.087
# parallel setting
cl <- makeCluster(8)
clusterExport(cl,ls())
## Estimation function
estimation <- function(count) {
Data<-DataGen(N,seed+count)
h <- 1.06*sd(Data$x)* N^{-2/7}
hopt <- 1.06*sd(Data$x)* N^{-1/5}
X<-Data$x
Z<-Data$z
D<-Data$d
Y<-Data$y
KSE1_est <- KSE_1(X,Y,D,Z,h)
KSE2_est <- KSE_2(X,Y,D,Z,h)
KSE3_est <- KSE_3(X,Y,D,Z,h)
KSET_est <- KSE_t(X,Y,D,Z,hopt)
# veff  <- estVeff(X,Y,D,Z,hopt)
# est <- cbind(T1est,T2est,T3est,Test,veff)
est <- cbind(KSE1_est,KSE2_est,KSE3_est,KSET_est)
return(est)
}
est  <- parSapply(cl,1:J,estimation)
est  <- t(est)
result <- matrix(nrow = 4, ncol = 4)
colnames(result)<-c("bias","stdev","RMSE","CR")
rownames(result)<-c("T1","T2","T3","T")
for (i in 1:4) {
Delta <- mean(est[,i])
bias  <- Delta - truevalue
mse   <- 1/J*(sum((est[,i]-truevalue)^2))
stdev <- sqrt(1/J*(sum((est[,i]-Delta)^2)))
rmse<- sqrt(mse)
count<-0
for(j in 1:J){
if(est[j,i]> 0.087-1.96*stdev & est[j,i]< 0.087+1.96*stdev)
count<- count+1
}
coverage_rate <<- count/J
CR <- coverage_rate
result[i,] <- cbind(bias,stdev,rmse,CR)
}
result
source("1.3 plot.R")
# plot
est.df <- data.frame(est1)
# plot
est.df <- data.frame(est)
plt_ATE(est.df)
## Monto Carlo times and Sample Size###
seed = 2021
J <- 500
N <- 500
truevalue<- 0.087
# parallel setting
cl <- makeCluster(16)
clusterExport(cl,ls())
## Estimation function
estimation <- function(count) {
Data<-DataGen(N,seed+count)
h <- 1.06*sd(Data$x)* N^{-2/7}
hopt <- 1.06*sd(Data$x)* N^{-1/5}
X<-Data$x
Z<-Data$z
D<-Data$d
Y<-Data$y
KSE1_est <- KSE_1(X,Y,D,Z,h)
KSE2_est <- KSE_2(X,Y,D,Z,h)
KSE3_est <- KSE_3(X,Y,D,Z,h)
KSET_est <- KSE_t(X,Y,D,Z,hopt)
# veff  <- estVeff(X,Y,D,Z,hopt)
# est <- cbind(T1est,T2est,T3est,Test,veff)
est <- cbind(KSE1_est,KSE2_est,KSE3_est,KSET_est)
return(est)
}
est  <- parSapply(cl,1:J,estimation)
est  <- t(est)
est  <- parSapply(cl,1:J,estimation)
est  <- t(est)
result <- matrix(nrow = 4, ncol = 4)
colnames(result)<-c("bias","stdev","RMSE","CR")
rownames(result)<-c("T1","T2","T3","T")
for (i in 1:4) {
Delta <- mean(est[,i])
bias  <- Delta - truevalue
mse   <- 1/J*(sum((est[,i]-truevalue)^2))
stdev <- sqrt(1/J*(sum((est[,i]-Delta)^2)))
rmse<- sqrt(mse)
count<-0
for(j in 1:J){
if(est[j,i]> 0.087-1.96*stdev & est[j,i]< 0.087+1.96*stdev)
count<- count+1
}
coverage_rate <<- count/J
CR <- coverage_rate
result[i,] <- cbind(bias,stdev,rmse,CR)
}
est  <- t(est)
result <- matrix(nrow = 4, ncol = 4)
colnames(result)<-c("bias","stdev","RMSE","CR")
rownames(result)<-c("T1","T2","T3","T")
for (i in 1:4) {
Delta <- mean(est[,i])
bias  <- Delta - truevalue
mse   <- 1/J*(sum((est[,i]-truevalue)^2))
stdev <- sqrt(1/J*(sum((est[,i]-Delta)^2)))
rmse<- sqrt(mse)
count<-0
for(j in 1:J){
if(est[j,i]> 0.087-1.96*stdev & est[j,i]< 0.087+1.96*stdev)
count<- count+1
}
coverage_rate <<- count/J
CR <- coverage_rate
result[i,] <- cbind(bias,stdev,rmse,CR)
}
result
# plot
est.df <- data.frame(est)
plt_ATE(est.df)
# Get helper functions (change ... to relevant folder)
rm(list=ls())
# library(tidyverse) #需要导出excel表格时调用的包
source("CSCM_helper_functions.R")
packages <- c("ggplot2", "Synth", "glmnet",
"dplyr", "osqp", "optimx")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
sapply(packages, require, character.only=TRUE)
library(openxlsx)
data <- read.xlsx("three_increase2.xlsx",sheet=1)
year = seq(2011.25,2020,0.25) #要使用的年份
data$time = year
